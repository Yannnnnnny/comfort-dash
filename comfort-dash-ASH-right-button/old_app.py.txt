
"""

import os
import argparse

import dash
import dash_bootstrap_components as dbc
import dash_mantine_components as dmc
from dash import Dash, dcc, html
from icecream import install, ic

from components.footer import my_footer
from components.navbar import my_navbar
from utils.my_config_file import (
    Config,
    Stores,
    ElementsIDs,
    Dimensions,
)
from utils.website_text import app_name

from dash.dependencies import Input, Output
from components.dropdowns import dd_model
from components.input_environmental_personal import input_environmental_personal
from components.dropdowns import chart_selection
from utils.my_config_file import (
    MODELS,
    AdaptiveEN,
    AdaptiveAshrae,
    PmvAshraeResultCard,
    PmvENResultCard,
    PhsResultCard,
)

install()
ic.configureOutput(includeContext=True)

# Parse command line arguments
parser = argparse.ArgumentParser(description="Run the Dash application.")
parser.add_argument('--host', type=str, default='127.0.0.1', help='Host to run the app on')
parser.add_argument('--port', type=int, default=9090, help='Port to run the app on')
parser.add_argument('--debug', action='store_true', help='Run the app in debug mode')
args = parser.parse_args()

# This is required by dash mantine components to work with react 18
dash._dash_renderer._set_react_version("18.2.0")

# Exposing the Flask Server to enable configuring it for logging in
app = Dash(
    __name__,
    title=app_name,
    update_title="Loading...",
    external_stylesheets=[
        dbc.themes.BOOTSTRAP,
        "https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css",
        # include google fonts
        "https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;900&display=swap",
        # dash mantine stylesheets
        "https://unpkg.com/@mantine/dates@7/styles.css",
        "https://unpkg.com/@mantine/code-highlight@7/styles.css",
        "https://unpkg.com/@mantine/charts@7/styles.css",
        "https://unpkg.com/@mantine/carousel@7/styles.css",
        "https://unpkg.com/@mantine/notifications@7/styles.css",
        "https://unpkg.com/@mantine/nprogress@7/styles.css",
    ],
    external_scripts=["https://cdn.plot.ly/plotly-basic-2.26.2.min.js"],
    prevent_initial_callbacks=True,
    use_pages=True,
    serve_locally=False,
)
app.config.suppress_callback_exceptions = True

app.layout = dmc.MantineProvider(
    defaultColorScheme="light",
    theme={
        "colorScheme": "dark",
        "fontFamily": "'Inter', sans-serif",
        "primaryColor": "indigo",
        "components": {
            "Button": {"styles": {"root": {"fontWeight": 400}}},
            "Alert": {"styles": {"title": {"fontWeight": 500}}},
            "AvatarGroup": {"styles": {"truncated": {"fontWeight": 500}}},
        },
    },
    children=html.Div(
        [
            my_navbar(),
            dcc.Location(id=ElementsIDs.URL.value),
            dcc.Store(id=Stores.INPUT_DATA.value, storage_type="local"),
            html.Div(
                dmc.Container(
                    dash.page_container,
                    p="xs",
                    size=Dimensions.default_container_width.value,
                ),
                style={
                    "paddingBottom": "6.5rem",
                },
            ),
            my_footer(),
        ],
        style={
            "minHeight": "100vh",
            "position": "relative",
        },
    ),
)


@app.callback(
    Output("input_card", "children"),
    Output("graph-container", "children"),
    Output("chart-select", "children"),
    Output("graph-container", "cols"),
    Input(dd_model["id"], "value"),
)
def capture_selected_model(selected_model):
    print(selected_model)
    input_content = input_environmental_personal(selected_model)
    graph_content = update_graph_content(selected_model)
    chart_content = chart_selection(selected_model)
    result_content = change_cols(selected_model)

    return input_content, graph_content, chart_content, result_content


def change_cols(selected_model):
    if (
        selected_model == MODELS.Adaptive_EN.value
        or selected_model == MODELS.Adaptive_ashrae.value
        or selected_model == MODELS.Phs.value
        
    ):
        cols = 1
        print("change_cols")
    else:
        cols = 3
    return cols


def update_graph_content(selected_model):
    if selected_model == MODELS.Adaptive_EN.value:
        grid_content = [
            dmc.Center(dmc.Text(AdaptiveEN.class_III.value)),
            dmc.Center(dmc.Text(AdaptiveEN.class_II.value)),
            dmc.Center(dmc.Text(AdaptiveEN.class_I.value)),
            dmc.Center(dmc.Text(AdaptiveEN.adaptive_chart.value)),
        ]
    elif selected_model == MODELS.Adaptive_ashrae.value:
        grid_content = [
            dmc.Center(dmc.Text(AdaptiveAshrae.acceptability_limits_80.value)),
            dmc.Center(dmc.Text(AdaptiveAshrae.acceptability_limits_90.value)),
            dmc.Center(dmc.Text(AdaptiveAshrae.adaptive_chart.value)),
        ]
    elif selected_model == MODELS.PMV_ashrae.value:
        grid_content = [
            dmc.Center(dmc.Text(PmvAshraeResultCard.pmv.value)),
            dmc.Center(dmc.Text(PmvAshraeResultCard.ppd.value)),
            dmc.Center(dmc.Text(PmvAshraeResultCard.sensation.value)),
            dmc.Center(dmc.Text(PmvAshraeResultCard.set.value)),
        ]
    elif selected_model == MODELS.PMV_EN.value:
        grid_content = [
            dmc.Center(dmc.Text(PmvENResultCard.pmv.value)),
            dmc.Center(dmc.Text(PmvENResultCard.ppd.value)),
            dmc.Center(dmc.Text(PmvENResultCard.set.value)),
        ]

    elif selected_model == MODELS.Fans_heat.value:
        grid_content = [
        ]

    elif selected_model == MODELS.Phs.value:
        grid_content = [
            dmc.Center(dmc.Text(PhsResultCard.line1.value)),
            dmc.Center(dmc.Text(PhsResultCard.line2.value)),
            dmc.Center(dmc.Text(PhsResultCard.line3.value)),
            dmc.Center(dmc.Text(PhsResultCard.line4.value)),
        ]

    return grid_content

def generate_dropdown_inline():
    return generate_dropdown_inline()


if __name__ == "__main__":
    app.run_server(
        debug=args.debug,
        host=args.host,
        port=args.port,
        processes=1,
        threaded=True,
    )
"""